# Generic-Synchronous-Asynchronous-FIFO-Memories
This repository contains the design and simulation files for both Synchronous and Asynchronous FIFO modules. These FIFO's are commonly used in digital systems for data buffering, clock domain crossing, and metastability mitigation, ensuring reliable data transfer between components operating at different clock frequencies.

Despite of being used for similar purposes, each FIFO module has a different use case depending on the application. Next are described each of the FIFO modules with their respective functional Diagram.

---

**Synchronous First-In First-Out memory**

The Synchronous FIFO is used when there are two subsystems that share the same system clock but each of them has events at different timing, for example theres a system inside an FPGA that contains a soft-core that works at 50MHz and needs to send data into an UART that send data at 9600 baud rate (1200bytes per second approx). In this case we should use a synchronous FIFO because both design share the same global clock but they function at different timing.

The module is composed buy three submodules, a synchronous-static random-access memory SSRAM that stores the values to be readed and written based on addresses and enable signals generated by both write and read controllers. The Write controller checks for write requests, checks the actual value of the RD pointer, generates the address where the data must be written, generates a Full flag when the write pointer have *wrraped around* the RD pointer (tells the user when there is no more room for writtes until Reads are completed) and generates an enable flag that tells the SSRAM when to write the data. The Read controller have a similar functionality of the write controller but it generates an Empty Flag when the RD pointer is equal to the Write pointer. The next image shows the functional diagram of the SFIFO:
<img width="1069" height="813" alt="SFIFO" src="https://github.com/user-attachments/assets/1ecde9aa-aa58-4439-a28d-9f6c8fd85de4" />


**Asynchronous First-In First-Out memory**

The asynchronous FIFO is a safe way to transmitt data between two systems that functions at different clock domains, it relies on synchronization methods and gray code encoding to avoid as much as possible metastability issues introduced by the use of separate clock sources, a typical example would be a DSP that works at 100MHz and a microprocessor system that works at 1GHz. The functionality is similar that the presented in the synchronous case but with important differences. The memory used is a dual-clock static random access memory DualClockSRAM that allows to read and write at different clock rates. the WR and RD controllers generates a gray encoded version of the pointers that pass through a two step (dual flip flop) synchronizer allowing to jump from one clock source to the other, the functional diagram is shown bellow:
<img width="1137" height="807" alt="AFIFO" src="https://github.com/user-attachments/assets/2e1e061f-524d-4cd5-815c-6d839b925f01" />

---

Both modules can be paramtrized choosing the data width (number of bits used in each write and read) to be stored and the FIFO Depth (amount of positions of the data memory). Because the write frequency should be greater than the read frecquency (if not FIFO is not the module you need), there will be a maximum number of consecutive valid writes until the memory is completely full, then the write part should wait some time before sending another burst. The user can calculate the required Burst Length based on the formulas presented above:
<img width="1117" height="716" alt="FIFO Formulas" src="https://github.com/user-attachments/assets/b43ad1fe-e34e-4333-9e3f-becb83ac15e5" />

these formulas can be used for both FIFO modules, but it is necessary to take into account that the Asynchronous module needs two cycles for synchronization, so at the end it will require another two extra memory slots to ensure a proper functionality. 

next is shwon an numeric example that calculates the necessary burst length between two systems with different write and read periods, the write side have a operation rade at 1MHz while the read side has an operation of 500KHz, each transaction have a with of 1 byte and the FIFO have a memory depth of 8 positions:
<img width="963" height="301" alt="Examples_" src="https://github.com/user-attachments/assets/da3eb536-1d47-4e48-ac01-04570f4f02f5" />

---

Next is shown the simulation waveform of the Synchronous FIFO module, it is possible to see how the controllers writes and reads data each time that the respective flag is asserted, we can see how the simulation asserts this two flags at different rates, resulting in the data transfer from a quicker source to a slower source. It is possible to see how the memory is written only when the possition has been readed before, ensuring that all data is readed before a next write. 

<img width="1423" height="544" alt="image" src="https://github.com/user-attachments/assets/ddd1a123-e7ea-4e6b-8423-2fd24b27f958" />



Next is shown the simulation waveform for the Asynchronous FIFO module, it is possible to see the two different clock domains of the design with the colors blue and yellow, at the midlle with purple color is found the Memory with all the content of each position. We can see how the ASYNC FIFO effectively transmitts the data from one domain tot he other, asserting the signals FIFOEmpty and FIFOReady, writing one data in one clock domain and reading the exact data in the same order in the other domain. It also can be appreciated in each domain the impact of the two-step synchronizer, affecting when the system starts reading after the writes start. 

<img width="1407" height="568" alt="image" src="https://github.com/user-attachments/assets/f5b17708-06b1-4f30-aab1-b34f966fe72b" />

